from flask import Flask, jsonify
from flask_cors import CORS

from functools import lru_cache
import datetime
import trade_engine
import backend_auth
from flask import request

app = Flask(__name__)
# Enable CORS for all routes (since frontend is file-based or separate)
CORS(app)

@app.route('/api/history/<ticker>')
# @lru_cache(maxsize=100) # Simple in-memory cache
def get_history(ticker):
    try:
        from dotenv import load_dotenv
        import os
        import requests
        import datetime
        
        load_dotenv()
        api_key = os.environ.get('TIINGO_API_KEY')
        if not api_key:
             return jsonify({"error": "TIINGO_API_KEY missing"}), 500

        print(f"Fetching history for {ticker} via Tiingo...")
        
        # 1. Fetch Company Meta Data
        headers = {'Content-Type': 'application/json'}
        meta_url = f"https://api.tiingo.com/tiingo/daily/{ticker}"
        params_meta = {'token': api_key}
        meta_response = requests.get(meta_url, params=params_meta, headers=headers)
        
        company_name = ticker
        if meta_response.status_code == 200:
             meta_data = meta_response.json()
             company_name = meta_data.get('name', ticker)

        # 2. Fetch Price History
        # Tiingo API dates
        end_date = datetime.datetime.now()
        start_date = "2010-01-01" # Full History
        
        print(f"Requesting Tiingo data for {ticker} from {start_date} to {end_date.strftime('%Y-%m-%d')}")
        
        hist_url = f"https://api.tiingo.com/tiingo/daily/{ticker}/prices"
        params_hist = {
            'startDate': start_date,
            'endDate': end_date.strftime('%Y-%m-%d'),
            'token': api_key,
            'resampleFreq': 'daily' 
        }
        
        response = requests.get(hist_url, params=params_hist, headers=headers)
        if response.status_code != 200:
            print(f"Tiingo Error: {response.text}")
            return jsonify({"symbol": ticker, "companyName": company_name, "history": []}), 200
            
        data = response.json()
        
        if data:
            print(f"Received {len(data)} points. Last point date: {data[-1].get('date')}")
        else:
            print("Received empty data list from Tiingo")
        
        # Format: [{"date": "YYYY-MM-DD", "price": 123.45}, ...]
        formatted_history = []
        for item in data:
            d_str = item.get('date', '').split('T')[0]
            price = item.get('close') or item.get('adjClose')
            
            if d_str and price is not None:
                formatted_history.append({
                    "date": d_str,
                    "price": round(float(price), 2)
                })
            
        return jsonify({
            "symbol": ticker,
            "companyName": company_name,
            "history": formatted_history
        })
        
    except Exception as e:
        print(f"Error fetching {ticker}: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/dashboard')
def get_dashboard():
    try:
        # Serve the JSON file generated by api_dashboard.py
        import json
        with open('dashboard_final.json', 'r') as f:
            data = json.load(f)
            
        # Hardcoded Sector Map for Heatmap
        sector_map = {
            'AAPL': 'Technology', 'MSFT': 'Technology', 'NVDA': 'Technology', 'GOOGL': 'Technology',
            'AMZN': 'Consumer Cyclical', 'TSLA': 'Consumer Cyclical', 'META': 'Technology',
            'JPM': 'Financials', 'BAC': 'Financials', 'WFC': 'Financials', 'C': 'Financials',
            'XOM': 'Energy', 'CVX': 'Energy', 'COP': 'Energy',
            'JNJ': 'Healthcare', 'PFE': 'Healthcare', 'UNH': 'Healthcare', 'LLY': 'Healthcare',
            'PG': 'Consumer Defensive', 'KO': 'Consumer Defensive', 'PEP': 'Consumer Defensive',
            'COST': 'Consumer Defensive', 'WMT': 'Consumer Defensive',
            'BA': 'Industrials', 'CAT': 'Industrials', 'GE': 'Industrials',
            'DIS': 'Communication Services', 'NFLX': 'Communication Services',
            'AMD': 'Technology', 'INTC': 'Technology', 'QCOM': 'Technology',
            'GS': 'Financials', 'MS': 'Financials'
        }
        
        # Inject Sector
        if 'signals' in data:
            for signal in data['signals']:
                ticker = signal.get('Ticker')
                signal['Sector'] = sector_map.get(ticker, 'Unclassified')
                
        return jsonify(data)
    except Exception as e:
         return jsonify({"error": "Dashboard data not ready", "details": str(e)}), 500

def get_live_price(ticker):
    """
    Robust price fetcher.
    1. Try using cached dashboard_final.json (Tiingo data)
    2. Fallback to yfinance if not found or stale
    """
    import requests
    import os
    
    try:
        # Method 1: Check existing dashboard cache
        with open('dashboard_final.json', 'r') as f:
            data = json.load(f)
            for signal in data.get('signals', []):
                if signal.get('Ticker') == ticker:
                    if 'Price' in signal and signal['Price']:
                        return float(signal['Price'])
    except Exception as e:
        print(f"Cache miss or error for {ticker}: {e}")

    # Method 2: Tiingo IEX (Real-time fallback)
    try:
        api_key = os.environ.get('TIINGO_API_KEY')
        if not api_key:
            print("TIINGO_API_KEY missing for live price fetch")
            return None
            
        url = f"https://api.tiingo.com/iex/{ticker}"
        headers = {'Content-Type': 'application/json'}
        params = {'token': api_key}
        
        response = requests.get(url, params=params, headers=headers, timeout=5)
        if response.status_code == 200:
            data = response.json()
            if data and isinstance(data, list):
                # Tiingo IEX returns a list: [{"tngoLast": 123.45, ...}]
                price = data[0].get('tngoLast') or data[0].get('last')
                if price:
                    return float(price)
            elif data and isinstance(data, dict):
                 # Handle potential error or diff format
                 pass
                 
    except Exception as e:
        print(f"Tiingo Price fetch error for {ticker}: {e}")
        
    return None

@app.route('/api/portfolio', methods=['GET'])
def get_portfolio_route():
    # 1. Auth
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith("Bearer "):
         return jsonify({"error": "Missing or invalid token"}), 401
    
    token = auth_header.split(" ")[1]
    uid = backend_auth.verify_token(token)
    
    if not uid:
        return jsonify({"error": "Invalid token"}), 401
        
    try:
        # 2. Get Data
        pf_data = trade_engine.get_portfolio(uid)
        
        # 3. Enrich with Live Prices (Unrealized P&L)
        holdings = pf_data.get('holdings', [])
        
        if holdings:
            total_value = 0.0
            
            for h in holdings:
                t = h['ticker']
                # Use robust fetcher
                current_price = get_live_price(t)
                
                if current_price is None:
                    current_price = h['avg_price'] # Fallback to cost basis
                
                h['current_price'] = round(current_price, 2)
                h['market_value'] = round(current_price * h['quantity'], 2)
                h['return_pct'] = round(((current_price - h['avg_price']) / h['avg_price']) * 100, 2)
                h['unrealized_pl'] = round((current_price - h['avg_price']) * h['quantity'], 2)
                
                total_value += h['market_value']
                
            pf_data['holdings'] = holdings
            pf_data['total_portfolio_value'] = round(total_value + pf_data['cash'], 2)
            pf_data['total_investment'] = round(sum(h['avg_price'] * h['quantity'] for h in holdings), 2)
            pf_data['total_unrealized_pl'] = round(sum(h['unrealized_pl'] for h in holdings), 2)
            
        else:
             pf_data['total_portfolio_value'] = pf_data['cash']
             pf_data['total_investment'] = 0.0
             pf_data['total_unrealized_pl'] = 0.0
             
        return jsonify(pf_data)
        
    except Exception as e:
        print(f"Portfolio Error: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/trade', methods=['POST'])
def trade_route():
    try:
        # 1. Auth
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith("Bearer "):
             return jsonify({"error": "Unauthorized"}), 401
        
        token = auth_header.split(" ")[1]
        uid = backend_auth.verify_token(token)
        if not uid: return jsonify({"error": "Invalid User"}), 401
        
        # 2. Input
        data = request.json
        ticker = data.get('ticker')
        action = data.get('action') # BUY / SELL
        quantity = data.get('quantity')
        
        if not all([ticker, action, quantity]):
            return jsonify({"error": "Missing fields"}), 400
            
        try:
            quantity = int(quantity)
            if quantity <= 0: raise ValueError
        except:
            return jsonify({"error": "Invalid quantity"}), 400
            
        # 3. Fetch Live Price (Authoritative)
        live_price = get_live_price(ticker)
        
        if not live_price:
             return jsonify({"error": "Could not fetch live price. Market data unavailable."}), 500
             
        # 4. Execute
        result = trade_engine.execute_trade(uid, ticker, action, quantity, live_price)
        
        if result['status'] == 'success':
            return jsonify({
                "message": f"Successfully {action} {quantity} {ticker} @ ${live_price:.2f}",
                "new_balance": result['new_balance']
            })
        else:
            return jsonify({"error": result['message']}), 400
            
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({"error": f"Internal Server Error: {str(e)}"}), 500

@app.route('/api/portfolio/<ticker>', methods=['DELETE'])
def delete_position_route(ticker):
    # 1. Auth
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith("Bearer "):
         return jsonify({"error": "Unauthorized"}), 401
    
    token = auth_header.split(" ")[1]
    uid = backend_auth.verify_token(token)
    if not uid: return jsonify({"error": "Invalid User"}), 401
    
    if not ticker:
         return jsonify({"error": "Missing ticker"}), 400
         
    try:
        trade_engine.delete_position(uid, ticker)
        return jsonify({"message": f"Deleted position {ticker}"})
    except Exception as e:
         return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    # Run on port 5001 to avoid conflicts with common 5000
    print("ðŸš€ History API running on http://localhost:5001")
    app.run(port=5001, debug=True)
